{
  "Checks if a value is present in another array or string": {
    "prefix": "contains",
    "body": [
      "/**",
      " * Checks if a value or any value in an array is present in another array or string.",
      " *",
      " * @param {Array|string} a - The array or string to search within.",
      " * @param {Array|string} b - The value or array of values to search for.",
      " * @returns {boolean} - True if the value or any value in the array is found, otherwise false.",
      " */",
      "function contains(a, b) {",
      "    if (Array.isArray(b)) {",
      "        return b.some(x => a.includes(x));",
      "    }",
      "    return a.includes(b);",
      "}"
    ],
    "scope": "javascript"
  },
  "Sums the values of a specified property in an array of objects": {
    "prefix": "sum",
    "body": [
      "/**",
      " * Sums the values of a specified property in an array of objects.",
      " *",
      " * @param {Array} arr - The array of objects.",
      " * @param {string} prop - The property to sum.",
      " * @returns {number} - The sum of the specified property values.",
      " */",
      "function sum(arr, prop) {",
      "    return arr.reduce((total, item) => total + item[prop], 0);",
      "}"
    ],
    "scope": "javascript"
  },
  "Shuffles an array in place": {
    "prefix": "shuffle",
    "body": [
      "/**",
      " * Shuffles an array in place.",
      " *",
      " * @param {Array} arr - The array to shuffle.",
      " * @returns {Array} - The shuffled array.",
      " */",
      "function shuffle(arr) {",
      "    let i = arr.length;",
      "    while (i > 0) {",
      "        const j = Math.floor(Math.random() * i);",
      "        i--;",
      "        [arr[i], arr[j]] = [arr[j], arr[i]];",
      "    }",
      "    return arr;",
      "}"
    ],
    "scope": "javascript"
  },
  "Check if exists inside an iframe and resize": {
    "prefix": "resizer",
    "body": [
      "/**",
      " * Checks if the atom is inside an iframe and does a resize",
      " *",
      " * @param {string} - The element containing the content (By default it is #gv-atom)",
      " */",
      "function resizeIframe(elem=\"#gv-atom\") {",
      "    if (window.frameElement) {",
      "        const target = document.querySelector(elem);",
      "        console.log(\"Inside version 1.1\");",
      "        window.parent.postMessage({",
      "            sentinel: 'amp',",
      "            type: 'embed-size',",
      "            height: document.body.scrollHeight",
      "        }, '*');",
      "        document.body.style.overflow = 'hidden';",
      "        window.frameElement.height = target.offsetHeight;",
      "        function onElementHeightChange(elm, callback) {",
      "            let lastHeight = elm.clientHeight;",
      "            let newHeight;",
      "            (function run() {",
      "                newHeight = elm.clientHeight;",
      "                if (lastHeight !== newHeight) callback();",
      "                lastHeight = newHeight;",
      "                if (elm.onElementHeightChangeTimer) {",
      "                    clearTimeout(elm.onElementHeightChangeTimer);",
      "                }",
      "                elm.onElementHeightChangeTimer = setTimeout(run, 200);",
      "            })();",
      "        }",
      "        onElementHeightChange(document.body, function() {",
      "            window.frameElement.height = target.offsetHeight;",
      "        });",
      "    }",
      "}"
    ],
    "scope": "javascript"
  },
  "Get JSON from URL": {
    "prefix": "getJson",
    "body": [
      "function getJson(url) {",
      "  return fetch(`${url}`).then(r => r.json());",
      "}"
    ],
    "scope": "javascript"
  },
  "Merge two objects": {
    "prefix": "mergeObjects",
    "body": [
      "/**",
      " * Merges properties from the source object into the target object.",
      " * If a property in the target object is not an object, it is overwritten by the source object property.",
      " * If a property in the source object is an object, the function is called recursively.",
      " *",
      " * @param {Object} to - The target object.",
      " * @param {Object} from - The source object.",
      " * @returns {Object} - The merged object.",
      " */",
      "function merge(to, from) {",
      "    for (const n in from) {",
      "        if (typeof to[n] != 'object') {",
      "            to[n] = from[n];",
      "        } else if (typeof from[n] == 'object') {",
      "            to[n] = merge(to[n], from[n]);",
      "        }",
      "    }",
      "    return to;",
      "}"
    ],
    "scope": "javascript"
  },
  "Media Query Mixins": {
    "prefix": "mq",
    "body": [
      "@include mq($until: mobile) {",
      "\t$0",
      "}",
      "",
      "@include mq($from: mobile, $until: mobileLandscape) {",
      "\t",
      "}",
      "",
      "@include mq($from: mobileLandscape, $until: tablet) {",
      "\t",
      "}",
      "",
      "@include mq($from: tablet, $until: desktop) {",
      "\t",
      "}",
      "",
      "@include mq($from: desktop, $until: leftCol) {",
      "\t",
      "}",
      "",
      "@include mq($from: leftCol, $until: wide) {",
      "\t",
      "}",
      "",
      "@include mq($from: wide) {",
      "\t",
      "}"
    ],
    "scope": "*"
  },
  "Mustache Template Renderer": {
    "prefix": "mustache",
    "body": [
      "/**",
      " * Renders a Mustache template with the given context.",
      " *",
      " * @param {string} template - The Mustache template to render.",
      " * @param {Object|Array} self - The context or array of contexts to render the template with.",
      " * @param {Object} parent - The parent context, if any.",
      " * @param {boolean} invert - A flag indicating whether to invert the context.",
      " * @returns {string} - The rendered template.",
      " */",
      "function mustache(template, self, parent, invert) {",
      "    var render = mustache;",
      "    var output = \"\";",
      "    var i;",
      "",
      "    function get(ctx, path) {",
      "        path = path.pop ? path : path.split(\".\");",
      "        ctx = ctx[path.shift()];",
      "        ctx = ctx != null ? ctx : \"\";",
      "        return (0 in path) ? get(ctx, path) : ctx;",
      "    }",
      "",
      "    self = Array.isArray(self) ? self : (self ? [self] : []);",
      "    self = invert ? (0 in self) ? [] : [1] : self;",
      "",
      "    for (i = 0; i < self.length; i++) {",
      "        var childCode = '';",
      "        var depth = 0;",
      "        var inverted;",
      "        var ctx = (typeof self[i] == \"object\") ? self[i] : {};",
      "        ctx = Object.assign({}, parent, ctx);",
      "        ctx[\"\"] = {\"\": self[i]};",
      "",
      "        template.replace(/([\\s\\S]*?)({{((\\/)|(\\^)|#)(.*?)}}|$)/g,",
      "            function(match, code, y, z, close, invert, name) {",
      "                if (!depth) {",
      "                    output += code.replace(/{{{(.*?)}}}|{{(!?)(&?)(>?)(.*?)}}/g,",
      "                        function(match, raw, comment, isRaw, partial, name) {",
      "                            return raw ? get(ctx, raw)",
      "                                : isRaw ? get(ctx, name)",
      "                                : partial ? render(get(ctx, name), ctx)",
      "                                : !comment ? new Option(get(ctx, name)).innerHTML",
      "                                : \"\";",
      "                        }",
      "                    );",
      "                    inverted = invert;",
      "                } else {",
      "                    childCode += depth && !close || depth > 1 ? match : code;",
      "                }",
      "                if (close) {",
      "                    if (!--depth) {",
      "                        name = get(ctx, name);",
      "                        if (/^f/.test(typeof name)) {",
      "                            output += name.call(ctx, childCode, function(template) {",
      "                                return render(template, ctx);",
      "                            });",
      "                        } else {",
      "                            output += render(childCode, name, ctx, inverted);",
      "                        }",
      "                        childCode = \"\";",
      "                    }",
      "                } else {",
      "                    ++depth;",
      "                }",
      "            }",
      "        );",
      "    }",
      "    return output;",
      "}"
    ],
    "scope": "javascript"
  },
  "Mustache Template Example": {
    "prefix": "mustache-example",
    "body": [
      "const template = `",
      "  var is {{var}}",
      "  zero value is {{zerovar}}",
      "  undefined var is {{undefinedvar}}",
      "  nested object is",
      "  {{#obj}}",
      "    {{#goes}}",
      "    {{deep}}",
      "    {{/goes}}",
      "  {{/obj}}",
      "  dot syntax is {{obj.goes.deep}}",
      "  dot syntax in section is {{#obj.goes}}{{deep}}{{/obj.goes}}",
      "  list is ",
      "  {{#list}}",
      "    {{item}}",
      "  {{/list}}",
      "  inverted is",
      "  {{^inverted}}",
      "    okay",
      "  {{/inverted}}",
      "  dot is",
      "  {{#dot}}",
      "    {{.}}",
      "  {{/dot}}",
      "  lambda is",
      "  {{#lambda}}",
      "    {{{raw}}}",
      "  {{/lambda}}",
      "  raw is {{{raw}}}",
      "  raw2 is {{&raw}}",
      "  comment is {{!not}} okay",
      "  partial is {{>partial}}",
      "`;",
      "",
      "const ctx = {",
      "  var: \"<okay>\",",
      "  obj: {goes: {deep: \"okay\"}},",
      "  list:[{item:\"okay\"},{item:\"okay2\"}],",
      "  dot: [\"okay\"],",
      "  raw: \"<okay>\",",
      "  inverted: false,",
      "  lambda: function (text, render) {",
      "    return \"<b>\" + render(text + this.dot[0]) + \"</b>\";",
      "  },",
      "  partial: \"{{{var}}}\",",
      "  zerovar: 0",
      "};",
      "",
      "const output = mustache(template, ctx);",
      "console.log(output);"
    ],
    "scope": "javascript"
  }
} 